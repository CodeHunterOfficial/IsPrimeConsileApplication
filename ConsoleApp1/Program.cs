//Вариант#1
/*
 Проверка на простоту за O(N)
Линейная проверка очень простая - надо просто перебрать все числа 
от 2 до N−1 и проверить, что N не делится ни на одно из них.
Отдельно обрабатывается случай для N=1.Но это необязательно
 * */

static bool isPrime1(long n)
{
    if (n == 1)
    {
        return false;
    }
    for (int i = 2; i < n; i++)
    {
        if (n % i == 0)
        {
            return false;
        }
    }
    return true;
}

Console.WriteLine( isPrime1(12587));
//Самый худший вариант

//Варинат 2
//Ускорение до O(sqrt(N))
static bool isPrime2(long n)
{
    if (n == 1)
    {
        return false;
    }
    for (long i = 2; i * i <= n; i++) //
    {
        if (n % i == 0)
        {
            return false;
        }
    }
    return true;
}
Console.WriteLine(isPrime2(12587));

//Варинат 2 в ином виде
static bool prime21(long n)
{
    for (long  i = 2; i <=Math.Sqrt(n); i++)
        if (n % i == 0)
            return false;
    return true;
}

Console.WriteLine(isPrime2(12587));

/*
 * Данная функция проверки числа на простоту достаточно эффективна — асимптотика ее работы O (sqrt(N)). Однако, иногда в спортивном программировании нужно уметь проверять число на простоту быстрее.
*/

//Вариант# 3

/*
В некоторых случаях, когда требуется выполнять такую проверку для чисел из некоторого диапазона, то целесообразно воспользоваться алгоритмом Решето Эратосфена.


Вероятностный алгоритм за O (log N) с тестом Ферма
Математическое обоснование теста Ферма достаточно хорошо описано в
https://ru.wikipedia.org/wiki/%D0%A2%D0%B5%D1%81%D1%82_%D0%A4%D0%B5%D1%80%D0%BC%D0%B0

Тест Ферма
Для того, чтобы проверить число N на простоту с достаточно хорошей вероятностью безошибочности, достаточно 100 раз проверить случайное число A тестом Ферма:

a^(n-1)==1( mod n)

Также стоит отметить, что числа A и N должны быть взаимно просты. Если это условие не выполняется, то число N — заведомо непростое.

*/
static bool ferma(long  x)
{
    if (x == 2)
        return true;
    Random rand=new Random();
    for (int i = 0; i < 100; i++)
    {
        long  a = (rand.NextInt64(x-2)) + 2;
        if (gcd(a, x) != 1)
            return false;
        if (pows(a, x - 1, x) != 1)
            return false;
    }
    return true;
}
/*
Отмечу, что данная функция проверки использует функции нахождения НОД, 
а также быстрого возведения в степень по модулю.

Нахождение НОД
Собственно, в нахождении НОДа двух чисел проблем меньше всего.
Воспользуемся алгоритмом Евклида:
*/

static long gcd(long  a, long  b)
{
    if (b == 0)
        return a;
    return gcd(b, a % b);
}

/*Быстрое возведение в степень по модулю
Быстрое возведение в степень (бинарное) известно довольно широко. 
Отмечу только, что при перемножении двух чисел типа  long может
произойти переполнение типа еще до того, как мы возьмем результат по модулю.
Поэтому используем функцию двоичного умножения двух чисел также по модулю. 
Ее смысл очень похож на быстрое возведение в степень.
*/

static long mul(long  a, long  b, long  m)
{
    if (b == 1)
        return a;
    if (b % 2 == 0)
    {
        long  t = mul(a, b / 2, m);
        return (2 * t) % m;
    }
    return (mul(a, b - 1, m) + a) % m;
}

static long pows(long  a,  long b, long  m)
{
    if (b == 0)
        return 1;
    if (b % 2 == 0)
    {
        long  t = pows(a, b / 2, m);
        return mul(t, t, m) % m;
    }
    return (mul(pows(a, b - 1, m), a, m)) % m;
}


/*
 * Точно также как и при возведении в степень, если 
 * второй множитель четный, то можно разделить его на 2,
 * и перейти к вычислению произведения чисел A и B/2. 
 * Иначе, нужно вычислить произведение чисел A и B — 1.

Асимптотика решения
Итоговая асимптотика проверки на простоту 
— O (K * log N * log N), где K — количество итераций 
теста Ферма, которое обычно равняется 100. 
Если требуется проверить на простоту число типа int, 
то можно обойтись без двоичного умножения.
Тогда асимптотика проверки на простоту будет равна O (K * log N).
*/

//Варинат 4 испольование тест BPSW на простоту чисел
//https://e-maxx.ru/algo/bpsw
//Не рекомендую!!!!


Console.WriteLine(ferma(12587));